---
layout: post
tags: [Python, Algorithm]
title: Python Algoritmsâ€”â€”Search
---
æœ¬æ–‡ä¸»è¦æ€»ç»“å‡ ç§åŸºæœ¬çš„æŸ¥æ‰¾ç®—æ³•ï¼Œçº¿æ€§æŸ¥æ‰¾æ³•ã€äºŒåˆ†æŸ¥æ‰¾æ³•åŠå“ˆå¸ŒæŸ¥æ‰¾æ³•ï¼›å¹¶ç»™å‡ºmap ADTçš„å®ç°ã€‚

æŸ¥æ‰¾ä¸»è¦å¯åˆ†ä¸ºé™æ€æŸ¥æ‰¾ã€åŠ¨æ€æŸ¥æ‰¾å’Œå“ˆå¸ŒæŸ¥æ‰¾ä¸‰ç§æ–¹å¼ã€‚

é™æ€æŸ¥æ‰¾çš„ä¸»è¦ç®—æ³•æœ‰ï¼šé¡ºåºæŸ¥æ‰¾ï¼ˆçº¿æ€§æŸ¥æ‰¾ï¼‰ã€æŠ˜åŠæŸ¥æ‰¾ï¼ˆäºŒåˆ†æŸ¥æ‰¾ï¼‰ã€åˆ†å—æŸ¥æ‰¾ï¼ˆç´¢å¼•é¡ºåºæŸ¥æ‰¾ï¼‰åŠé™æ€æ ‘æŸ¥æ‰¾ã€‚

åŠ¨æ€æŸ¥æ‰¾ä¸»è¦æ˜¯é€šè¿‡äºŒå‰æ’åºæ ‘ï¼ˆæˆ–äºŒå‰æŸ¥æ‰¾æ ‘ï¼‰ï¼Œå…¶æŸ¥æ‰¾å½¢å¼ä¸æŠ˜åŠæŸ¥æ‰¾ç±»ä¼¼ï¼Œä½†é‡‡ç”¨é“¾å¼å­˜å‚¨ã€‚å½“äºŒå‰æ’åºæ ‘å‘ˆç°å•æ”¯æ ‘ï¼ˆæ•°æ®æœ‰åºï¼‰çš„å½¢æ€æ—¶ï¼ŒæŸ¥æ‰¾æ—¶é—´æ•ˆç‡ä¸çº¿æ€§æŸ¥æ‰¾ç›¸åŒï¼Œæœ€å¥½çš„æƒ…å†µå¯ä¸æŠ˜åŠæŸ¥æ‰¾ä¸€æ ·è¾¾åˆ°O(logn)ã€‚ä½¿äºŒå‰æ’åºæ ‘å¹³è¡¡å¯æé«˜æŸ¥æ‰¾æ•ˆç‡ã€‚å…·ä½“å®ç°ç»†èŠ‚è§Treeçš„ç›¸å…³æ€»ç»“ã€‚

### The Sequential Search

#### Implement

```python
def sequential_search(a_list, item):
    pos = 0
    found = False

    while pos < len(a_list) and not found:
        if a_list[pos] == item:
            found = True
        else:
            pos = pos + 1
    return found

def ordered_sequential_search(a_list, item):
    pos = 0
    found = False
    stop = False
    while pos < len(a_list) and not found and not stop:
        if a_list[pos] == item:
            found = True
        else:
            if a_list[pos] > item:
                stop = True
            else:
                pos = pos + 1
    return found
```

#### Analysis of The Sequential Search
é¡ºåºæŸ¥æ‰¾ç®—æ³•ç®€å•ï¼Œå¯¹é¡ºåºç»“æ„å’Œé“¾è¡¨ç»“æœå‡é€‚ç”¨ã€‚
é¡ºåºæŸ¥æ‰¾çš„æ—¶é—´æ•ˆç‡å¤ªä½ï¼Œä¸ºğ‘‚(ğ‘›)ã€‚æœ‰åºåˆ—è¡¨ä»…èƒ½åœ¨æŸ¥æ‰¾ä¸æˆåŠŸæ—¶æé«˜æ•ˆç‡ã€‚

+ **Analysis of The Sequential Search on common list**
![analsis1](/assets/blog/20140823_analysis1.png)

+ **Analysis of The Sequential Search on ordered list**
![analsis1](/assets/blog/20140823_analysis2.png)


### The Binary Search

#### Implement

```python
def binary_search(a_list, item):
    first = 0
    last = len(a_list) - 1
    found = False

    while first <= last and not found:
        midpoint = (first + last) // 2
        if a_list[midpoint] == item:
            found = True
        else:
            if item < a_list[midpoint]:
                last = midpoint - 1
            else:
                first = midpoint + 1
    return found


def binary_search_recursive(a_list, item):
    if len(a_list) == 0:
        return False
    else:
        midpoint = len(a_list) // 2
        if a_list[midpoint] == item:
            return True
        else:
            if item < a_list[midpoint]:
                return binary_search_recursive(a_list[:midpoint], item)
            else:
                return binary_search_recursive(a_list[midpoint+1:], item)
```

#### Analysis of The Binary Search
äºŒåˆ†æŸ¥æ‰¾åªé€‚ç”¨äºæœ‰åºè¡¨åŠé¡ºåºå­˜å‚¨ç»“æ„ï¼Œå¯¹æ•°æ®è¿›è¡Œå…¨æ’åºã€‚
äºŒåˆ†æŸ¥æ‰¾çš„æ—¶é—´æ•ˆç‡ä¸ºğ‘‚(log ğ‘›)ã€‚


### åˆ†å—æŸ¥æ‰¾
åˆ†å—æŸ¥æ‰¾çš„æ€è·¯æ˜¯ï¼š
å…ˆè®©æ•°æ®åˆ†å—æœ‰åºï¼Œå³åˆ†æˆè‹¥å¹²å­è¡¨ï¼Œè¦æ±‚æ¯ä¸ªå­è¡¨ä¸­çš„æ•°æ®å…ƒç´ å€¼éƒ½æ¯”åä¸€å—ä¸­çš„æ•°å€¼å°ï¼ˆå­è¡¨å†…ä¸ä¸€å®šæœ‰åºï¼‰ï¼Œç„¶åå°†å„å­è¡¨ä¸­çš„æœ€å¤§å…³é”®å­—æ„æˆä¸€ä¸ªç´¢å¼•è¡¨ï¼Œè¡¨ä¸­è¿˜åŒ…å«æ¯ä¸ªå­è¡¨çš„èµ·å§‹åœ°å€ã€‚ï¼ˆ**å—é—´æœ‰åºï¼Œå—å†…æ— åº**ï¼‰
å¯¹ç´¢å¼•è¡¨è¿›è¡ŒæŠ˜åŠæŸ¥æ‰¾ï¼Œç¡®å®šå¾…æŸ¥å…³é”®å­—æ‰€åœ¨å­è¡¨åï¼Œåœ¨å­è¡¨å†…é‡‡ç”¨é¡ºåºæŸ¥æ‰¾ã€‚


### Hashing

#### Common Hash Functions
+ é™¤ç•™ä½™æ•°æ³•ï¼ˆremainder methodï¼‰: å–ä½™æ•°
+ æŠ˜å æ³•ï¼ˆfolding methodï¼‰ï¼šåŸå­—ç¬¦ä¸²åˆ†ç»„æ±‚å’Œå†å–æ¨¡
+ å¹³æ–¹å–ä¸­æ³•ï¼ˆmid-square methodï¼‰ï¼šå¯¹æ•°å­—è¿›è¡Œå¹³æ–¹è¿ç®—ï¼Œç„¶åå–å…¶ä¸­é—´ä¸¤ä½æ•°ï¼Œå†å–æ¨¡
+ `ord`å‡½æ•°ï¼šå¯¹äºæœ‰å­—ç¬¦çš„å…ƒç´ ä½¿ç”¨`ord`å‡½æ•°ï¼Œå°†å­—ç¬¦ä¸²è½¬æ¢æˆä¸€ä¸ªæœ‰åºçš„æ•°å€¼åºåˆ—ã€‚åœ¨Pythonä¸­ï¼Œ`ord`å‡½æ•°å¯ä»¥å¾—åˆ°å¯¹åº”å­—ç¬¦çš„ASCIIç å€¼ã€‚å°†æ‰€æœ‰å­—ç¬¦çš„ç å€¼ç´¯åŠ å†å–ä½™æ•°ï¼ˆå›æ–‡æ„è¯æ³•æ„æˆçš„å­—ç¬¦ä¸²å¾—åˆ°çš„å€¼æ€»æ˜¯ä¸€æ ·çš„ï¼Œå¯ä»¥æ ¹æ®å­—ç¬¦çš„ä½ç½®æ·»åŠ ä¸€ä¸ªæƒé‡ï¼‰
+ ç›´æ¥å¯»å€æ³•ï¼šå–å…³é”®ç æˆ–å…³é”®ç çš„æŸä¸ªçº¿æ€§å‡½æ•°å€¼çš„æ•£åˆ—åœ°å€ï¼›å³hash(k)=aÂ·k+bï¼ˆa,bä¸ºå¸¸æ•°ï¼‰
+ ä¹˜ä½™å–æ•´æ³•ï¼šå°†å…³é”®ç ä¹˜ä»¥aï¼Œå–å…¶å°æ•°éƒ¨åˆ†ï¼Œç„¶åå†æ”¾å¤§bå€å¹¶å–æ•´ï¼›å³hash(k)=bÂ·(aÂ·k mod 1)(a,bä¸ºå¸¸æ•°)
+ æ•°å­—åˆ†ææ³•ï¼šé€‰ç”¨å…³é”®å­—çš„æŸå‡ ä½ç»„åˆæˆå“ˆå¸Œåœ°å€ã€‚ï¼ˆé€‰ç”¨åŸåˆ™ï¼šå„ç§ç¬¦å·åœ¨è¯¥ä½ä¸Šå‡ºç°çš„é¢‘ç‡å¤§è‡´ç›¸åŒï¼‰
+ éšæœºæ•°æ³•ï¼šé€‚ç”¨äºé•¿åº¦ä¸ç­‰çš„æƒ…å†µï¼›hash(k) = random(k)

#### Collision Resolusion
+ å¼€æ”¾å¯»å€æ³•(open addressï¼‰ï¼šçº¿æ€§æ¢æµ‹ï¼ˆlinear probingï¼‰ä¸‹ä¸€ä¸ªä½ç½®ï¼›å³Hi = (Hash(key)+di) mod m (mä¸ºå“ˆå¸Œè¡¨é•¿åº¦ï¼›dä¸ºå¢é‡åºåˆ—1ï¼Œ2ï¼Œâ€¦â€¦m-1ï¼Œä¸”di=i)ã€‚
	ç¼ºç‚¹æ˜¯å®¹æ˜“é€ æˆèšé›†ç°è±¡ï¼ˆclusterï¼‰ï¼Œè§£å†³èšé›†ç°è±¡çš„åŠæ³•æ˜¯è·³è·ƒå¼åœ°æŸ¥æ‰¾ä¸‹ä¸€ä¸ªç©ºæ§½ã€‚
+ å¹³æ–¹æ¢æµ‹æ³•ï¼ˆquadratic probingï¼‰ï¼šHi = (Hash(key)+di) mod m (mä¸ºå“ˆå¸Œè¡¨é•¿åº¦ï¼Œè¦æ±‚ä¸ºæŸä¸ª4k+3çš„è´¨æ•°ï¼›dä¸ºå¢é‡åºåˆ—1ï¼Œ4ï¼Œ9â€¦â€¦ï¼Œä¸”di=i^2)
+ é“¾åœ°å€æ³•ï¼ˆChainingï¼‰ï¼šå°†å…·æœ‰ç›¸åŒå“ˆå¸Œåœ°å€çš„è®°å½•é“¾æˆä¸€ä¸ªå•é“¾è¡¨ï¼Œç”¨ä¸€ä¸ªæ•°ç»„å°†mä¸ªå•é“¾è¡¨çš„è¡¨å¤´æŒ‡é’ˆå­˜å‚¨èµ·æ¥ã€‚
![chaining](/assets/blog/20140823_chaining.png)
+ å†å“ˆå¸Œæ³•ï¼šå½“äº§ç”Ÿå†²çªæ—¶è®¡ç®—å¦ä¸€ä¸ªå“ˆå¸Œå‡½æ•°ï¼Œç›´åˆ°å†²çªä¸å†å‘ç”Ÿã€‚Hi = RHi(k)
+ å»ºç«‹ä¸€ä¸ªå…¬å…±æº¢å‡ºåŒºï¼šä¸€æ—¦å‘ç”Ÿå†²çªï¼Œéƒ½å¡«å…¥æº¢å‡ºè¡¨

#### Analysis of Hashing

å“ˆå¸ŒæŸ¥æ‰¾çš„è¿‡ç¨‹ä¸å“ˆå¸Œé€ è¡¨çš„è¿‡ç¨‹åŸºæœ¬ä¸€è‡´ã€‚ç”±äºæœ‰å†²çªäº§ç”Ÿï¼Œå“ˆå¸ŒæŸ¥æ‰¾çš„è¿‡ç¨‹ä»ç„¶è¦è¿›è¡Œæ¯”è¾ƒï¼Œä»ç„¶è¦ä»¥å¹³å‡æŸ¥æ‰¾é•¿åº¦ASLæ¥è¡¡é‡ï¼Œ**å“ˆå¸ŒæŸ¥æ‰¾çš„æ—¶é—´æ•ˆç‡å¹¶ä¸æ˜¯çœŸæ­£ä¸ºğ‘‚(1)**ã€‚å“ˆå¸Œè¡¨çš„æŸ¥æ‰¾æ€§èƒ½ä¸è½½è·å› å­ï¼ˆload factor, Î»ï¼‰æœ‰å…³ã€‚
> Î» = number of items / table size

Î»è¡¨ç¤ºå“ˆå¸Œè¡¨çš„è£…æ»¡ç¨‹åº¦ã€‚Î»è¶Šå¤§ï¼Œè¡¨æ˜å¡«å…¥è¡¨ä¸­çš„å…ƒç´ è¶Šå¤šï¼Œäº§ç”Ÿå†²çªçš„å¯èƒ½æ€§å°±è¶Šå¤§ï¼ŒæŸ¥æ‰¾æ—¶æ¯”è¾ƒæ¬¡æ•°å°±è¶Šå¤šã€‚å®é™…ä¸Šï¼Œå“ˆå¸Œè¡¨çš„å¹³å‡æŸ¥æ‰¾é•¿åº¦æ˜¯è½½è·å› å­çš„å‡½æ•°ï¼Œåªæ˜¯ä¸åŒå¤„ç†å†²çªçš„æ–¹æ³•æœ‰ä¸åŒçš„å‡½æ•°ã€‚
> å¯¹äºå¼€æ”¾å¯»å€æ³•ï¼Œè·è½½å› å­æ˜¯ç‰¹åˆ«é‡è¦å› ç´ ï¼Œåº”ä¸¥æ ¼é™åˆ¶åœ¨0.7-0.8ä»¥ä¸‹ã€‚è¶…è¿‡0.8ï¼ŒæŸ¥è¡¨æ—¶çš„CPUç¼“å­˜ä¸å‘½ä¸­ï¼ˆcache missingï¼‰æŒ‰ç…§æŒ‡æ•°æ›²çº¿ä¸Šå‡ã€‚å› æ­¤ï¼Œä¸€äº›é‡‡ç”¨å¼€æ”¾å¯»å€æ³•çš„hashåº“ï¼Œå¦‚Javaçš„ç³»ç»Ÿåº“é™åˆ¶äº†è·è½½å› å­ä¸º0.75ï¼Œè¶…è¿‡æ­¤å€¼å°†resizeæ•£åˆ—è¡¨ã€‚


### `Map` ADT

we use two lists to create a `HashTable` class that implements the Map abstract data type.

+ `Map()` Create a new, empty map. It returns an empty map collection.
+ `put(key,val)` Add a new key-value pair to the map. If the key is already in the map then replace the old value with the new value.
+ `get(key)` Given a key, return the value stored in the map or `None` otherwise.
+ `del` Delete the key-value pair from the map using a statement of the form `del map[key]`.
+ `len()` Return the number of key-value pairs stored in the map.
+ `in` Return `True` for a statement of the form `key in map`, if the given key is in the map, False otherwise.

```python
class HashTable:
    def __init__(self):
        self.size = 11
        self.slots = [None] * self.size
        self.data = [None] * self.size

    def put(self, key, data):
        hashvalue = self.hashfunction(key, len(self.slots))

        if self.slots[hashvalue] == None:
            self.slots[hashvalue] = key
            self.data[hashvalue] = data
        else:
            if self.slots[hashvalue] == key:
                self.data[hashvalue] = data    # replace
            else:
                nextslot = self.rehash(hashvalue, len(self.slots))
                while self.slots[nextslot] != None and self.slots[nextslot] != key:
                    nextslot = self.rehash(nextslot, len(self.slots))
                if self.slots[nextslot] == None:
                    self.slots[nextslot] = key
                    self.data[nextslot] = data
                else:
                    self.data[nextslot] = data    #replace

    def hashfunction(self, key, size):
        return key % size

    def rehash(self, oldhash, size):
        return (oldhash + 1) % size

    def get(self, key):
        startslot = self.hashfunction(key, len(self.slots))

        data = None
        stop = False
        found = False
        position = startslot
        while self.slots[position] != None and not found and not stop:
            if self.slots[position] == key:
                found = True
                data = self.data[position]
            else:
                position = self.rehash(position, len(self.slots))
                if position == startslot:
                    stop = True
        return data

    def __getitem__(self, key):
        return self.get(key)

    def __setitem__(self, key.data):
        self.put(kay, data)
```
